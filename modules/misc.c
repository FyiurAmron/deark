// This file is part of Deark, by Jason Summers.
// This software is in the public domain. See the file COPYING for details.

// This file is for miscellaneous formats that are easy to support.
// Combining them in one file speeds up compilation and development time.

#include <deark-config.h>
#include <deark-modules.h>
#include "fmtutil.h"

// **************************************************************************
// "copy" module
//
// This is a trivial module that makes a copy of the input file.
// **************************************************************************

static int de_identify_copy(deark *c)
{
	return 0;
}

static void de_run_copy(deark *c, const char *params)
{
	de_dbg(c, "In copy module\n");

	dbuf_create_file_from_slice(c->infile, 0, c->infile->len, "bin", NULL);
}

void de_module_copy(deark *c, struct deark_module_info *mi)
{
	mi->id = "copy";
	mi->run_fn = de_run_copy;
	mi->identify_fn = de_identify_copy;
}

// **************************************************************************
// zlib module
//
// This module is for decompressing zlib-compressed files.
// It uses the deark-miniz.c utilities, which in turn use miniz.c.
// **************************************************************************

static void de_run_zlib(deark *c, const char *params)
{
	dbuf *f = NULL;

	de_dbg(c, "In zlib module\n");

	f = dbuf_create_output_file(c, "unc", NULL);
	de_uncompress_zlib(c->infile, 0, c->infile->len, f);
	dbuf_close(f);
}

static int de_identify_zlib(deark *c)
{
	de_byte b[2];
	de_read(b, 0, 2);

	if((b[0]&0x0f) != 8)
		return 0;

	if(b[0]<0x08 || b[0]>0x78)
		return 0;

	if(((((unsigned int)b[0])<<8)|b[1])%31 != 0)
		return 0;

	return 50;
}

void de_module_zlib(deark *c, struct deark_module_info *mi)
{
	mi->id = "zlib";
	mi->run_fn = de_run_zlib;
	mi->identify_fn = de_identify_zlib;
}

// **************************************************************************
// HP 100LX / HP 200LX .ICN icon format
// **************************************************************************

static void de_run_hpicn(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 width, height;
	de_int64 src_rowspan;
	de_int64 j;

	de_dbg(c, "In hpicn module\n");

	width = de_getui16le(4);
	height = de_getui16le(6);

	img = de_bitmap_create(c, width, height, 1);
	src_rowspan = (width+7)/8;

	for(j=0; j<height; j++) {
		de_convert_row_bilevel(c->infile, 8+j*src_rowspan, img, j, DE_CVTR_WHITEISZERO);
	}

	de_bitmap_write_to_file(img, NULL);
	de_bitmap_destroy(img);
}

static int de_identify_hpicn(deark *c)
{
	de_byte b[8];
	de_read(b, 0, 8);
	if(!de_memcmp(b, "\x01\x00\x01\x00\x2c\x00\x20\x00", 8))
		return 100;
	if(!de_memcmp(b, "\x01\x00\x01\x00", 4))
		return 60;
	return 0;
}

void de_module_hpicn(deark *c, struct deark_module_info *mi)
{
	mi->id = "hpicn";
	mi->run_fn = de_run_hpicn;
	mi->identify_fn = de_identify_hpicn;
}


// **************************************************************************
// X11 "puzzle" format
// ftp://ftp.x.org/pub/unsupported/programs/puzzle/
// This is the format generated by Netpbm's ppmtopuzz utility.
// **************************************************************************

struct xpuzzctx {
	de_int64 w, h;
	de_int64 palentries;
};

static int xpuzz_read_header(deark *c, struct xpuzzctx *d)
{
	d->w = de_getui32be(0);
	d->h = de_getui32be(4);
	d->palentries = (de_int64)de_getbyte(8);
	if(d->w<1 || d->w>DE_MAX_IMAGE_DIMENSION) return 0;
	if(d->h<1 || d->h>DE_MAX_IMAGE_DIMENSION) return 0;
	if(d->palentries==0) d->palentries = 256;
	return 1;
}

static void de_run_xpuzzle(deark *c, const char *params)
{
	struct xpuzzctx *d = NULL;
	struct deark_bitmap *img = NULL;
	de_int64 i, j;
	de_uint32 pal[256];
	de_int64 p;

	de_dbg(c, "In xpuzzle module\n");

	d = de_malloc(c, sizeof(struct xpuzzctx));
	if(!xpuzz_read_header(c, d)) goto done;

	img = de_bitmap_create(c, d->w, d->h, 3);

	// Read the palette
	de_memset(pal, 0, sizeof(pal));
	p = 9;
	for(i=0; i<d->palentries; i++) {
		pal[i] = DE_MAKE_RGB(de_getbyte(p), de_getbyte(p+1), de_getbyte(p+2));
		p+=3;
	}

	// Read the bitmap
	for(j=0; j<d->h; j++) {
		for(i=0; i<d->w; i++) {
			de_bitmap_setpixel_rgb(img, i, j, pal[de_getbyte(p+d->w*j+i)]);
		}
	}

	de_bitmap_write_to_file(img, NULL);

done:
	de_bitmap_destroy(img);
	de_free(c, d);
}

static int de_identify_xpuzzle(deark *c)
{
	struct xpuzzctx *d = NULL;
	int retval = 0;

	d = de_malloc(c, sizeof(struct xpuzzctx));

	if(!xpuzz_read_header(c, d)) goto done;

	if(d->w * d->h + 3*d->palentries + 9 == c->infile->len) {
		retval = 20;
	}

done:
	de_free(c, d);
	return retval;
}

void de_module_xpuzzle(deark *c, struct deark_module_info *mi)
{
	mi->id = "xpuzzle";
	mi->run_fn = de_run_xpuzzle;
	mi->identify_fn = de_identify_xpuzzle;
}

// **************************************************************************
// Winzle! puzzle image
// **************************************************************************

static void de_run_winzle(deark *c, const char *params)
{
	de_byte buf[256];
	de_int64 xorsize;
	de_int64 i;
	dbuf *f = NULL;

	xorsize = c->infile->len >= 256 ? 256 : c->infile->len;
	de_read(buf, 0, xorsize);
	for(i=0; i<xorsize; i++) {
		buf[i] ^= 0x0d;
	}

	f = dbuf_create_output_file(c, "bmp", NULL);
	dbuf_write(f, buf, xorsize);
	if(c->infile->len > 256) {
		dbuf_copy(c->infile, 256, c->infile->len - 256, f);
	}
	dbuf_close(f);
}

static int de_identify_winzle(deark *c)
{
	de_byte b[18];
	de_read(b, 0, sizeof(b));

	if(b[0]==0x4f && b[1]==0x40) {
		if(b[14]==0x25 && b[15]==0x0d && b[16]==0x0d && b[17]==0x0d) {
			return 95;
		}
		return 40;
	}
	return 0;
}

void de_module_winzle(deark *c, struct deark_module_info *mi)
{
	mi->id = "winzle";
	mi->run_fn = de_run_winzle;
	mi->identify_fn = de_identify_winzle;
}

// **************************************************************************
// DCX
// **************************************************************************

static void de_run_dcx(deark *c, const char *params)
{
	de_uint32 *page_offset;
	de_int64 num_pages;
	de_int64 page;
	de_int64 page_size;

	de_dbg(c, "In dcx module\n");

	page_offset = de_malloc(c, 1023 * sizeof(de_uint32));
	num_pages = 0;
	while(num_pages < 1023) {
		page_offset[num_pages] = (de_uint32)de_getui32le(4 + 4*num_pages);
		if(page_offset[num_pages]==0)
			break;
		num_pages++;
	}

	de_dbg(c, "number of pages: %d\n", (int)num_pages);

	for(page=0; page<num_pages; page++) {
		if(page == num_pages-1) {
			// Last page. Asssume it goes to the end of file.
			page_size = c->infile->len - page_offset[page];
		}
		else {
			page_size = page_offset[page+1] - page_offset[page];
		}
		if(page_size<0) page_size=0;
		de_dbg(c, "page %d at %d, size=%d\n", (int)page, (int)page_offset[page],
			(int)page_size);

		dbuf_create_file_from_slice(c->infile, page_offset[page], page_size, "pcx", NULL);
	}
}

static int de_identify_dcx(deark *c)
{
	de_byte b[4];
	de_read(b, 0, 4);
	if(!de_memcmp(b, "\xb1\x68\xde\x3a", 4))
		return 100;
	return 0;
}

void de_module_dcx(deark *c, struct deark_module_info *mi)
{
	mi->id = "dcx";
	mi->run_fn = de_run_dcx;
	mi->identify_fn = de_identify_dcx;
}

// **************************************************************************
// Minolta RAW (MRW)
// **************************************************************************

static void do_mrw_seg_list(deark *c, de_int64 pos1, de_int64 len)
{
	de_int64 pos;
	de_byte seg_id[4];
	de_int64 data_len;

	pos = pos1;
	while(pos < pos1+len) {
		de_read(seg_id, pos, 4);
		data_len = de_getui32be(pos+4);
		pos+=8;
		if(pos+data_len > pos1+len) break;
		if(!de_memcmp(seg_id, "\0TTW", 4)) { // Exif
			de_fmtutil_handle_exif(c, pos, data_len);
		}
		pos+=data_len;
	}
}

static void de_run_mrw(deark *c, const char *params)
{
	de_int64 mrw_seg_size;

	mrw_seg_size = de_getui32be(4);
	do_mrw_seg_list(c, 8, mrw_seg_size);
}

static int de_identify_mrw(deark *c)
{
	de_byte b[4];
	de_read(b, 0, 4);
	if(!de_memcmp(b, "\x00\x4d\x52\x4d", 4))
		return 100;
	return 0;
}

void de_module_mrw(deark *c, struct deark_module_info *mi)
{
	mi->id = "mrw";
	mi->run_fn = de_run_mrw;
	mi->identify_fn = de_identify_mrw;
}

// **************************************************************************
// "Bob" bitmap image
// Used by the Bob ray tracer.
// **************************************************************************

static void de_run_bob(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 w, h;
	de_int64 i, j;
	de_uint32 pal[256];
	de_int64 p;

	de_dbg(c, "In bob module\n");

	w = de_getui16le(0);
	h = de_getui16le(2);
	if(!de_good_image_dimensions(c, w, h)) goto done;
	img = de_bitmap_create(c, w, h, 3);

	// Read the palette
	de_memset(pal, 0, sizeof(pal));
	p = 4;
	for(i=0; i<256; i++) {
		pal[i] = DE_MAKE_RGB(de_getbyte(p), de_getbyte(p+1), de_getbyte(p+2));
		p+=3;
	}

	// Read the bitmap
	for(j=0; j<h; j++) {
		for(i=0; i<w; i++) {
			de_bitmap_setpixel_rgb(img, i, j, pal[de_getbyte(p+w*j+i)]);
		}
	}

	de_bitmap_write_to_file(img, NULL);

done:
	de_bitmap_destroy(img);
}

static int de_identify_bob(deark *c)
{
	de_int64 w, h;

	if(!de_input_file_has_ext(c, "bob")) return 0;

	w = de_getui16le(0);
	h = de_getui16le(2);
	if(c->infile->len == 4 + 768 + w*h) {
		return 100;
	}
	return 0;
}

void de_module_bob(deark *c, struct deark_module_info *mi)
{
	mi->id = "bob";
	mi->run_fn = de_run_bob;
	mi->identify_fn = de_identify_bob;
}

// **************************************************************************
// Vivid .img bitmap image
// Used by the Vivid ray tracer.
// **************************************************************************

static void de_run_vivid(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 w, h;
	de_int64 i;
	de_int64 pos;
	de_int64 firstline;
	de_int64 depth;
	de_int64 xpos, ypos;
	de_int64 runlen;
	de_byte r, g, b;
	de_uint32 clr;

	de_dbg(c, "In vivid module\n");

	w = de_getui16be(0);
	h = de_getui16be(2);
	firstline = de_getui16be(4);
	depth = de_getui16be(8);

	if(!de_good_image_dimensions(c, w, h)) goto done;
	if(firstline >= h) goto done;
	if(depth!=24) {
		de_err(c, "Unsupported image type\n");
		goto done;
	}

	img = de_bitmap_create(c, w, h, 3);

	pos = 10;
	xpos = 0;
	// I don't know for sure what to do with the "first scanline" field, in the
	// unlikely event it is not 0. The documentation doesn't say.
	ypos = firstline;
	while(1) {
		if(pos+4 > c->infile->len) {
			break; // EOF
		}
		runlen = (de_int64)de_getbyte(pos);
		b = de_getbyte(pos+1);
		g = de_getbyte(pos+2);
		r = de_getbyte(pos+3);
		pos+=4;
		clr = DE_MAKE_RGB(r, g, b);

		for(i=0; i<runlen; i++) {
			de_bitmap_setpixel_rgb(img, xpos, ypos, clr);
			xpos++; // Runs are not allowed to span rows
		}

		if(xpos >= w) {
			xpos=0;
			ypos++;
		}
	}

	de_bitmap_write_to_file(img, NULL);
done:
	de_bitmap_destroy(img);
}

static int de_identify_vivid(deark *c)
{
	de_int64 w, h, firstline, lastline, depth;

	if(!de_input_file_has_ext(c, "img")) return 0;

	w = de_getui16be(0);
	h = de_getui16be(2);
	firstline = de_getui16be(4);
	lastline = de_getui16be(6);
	depth = de_getui16be(8);

	if(depth!=24) return 0;
	if(firstline>lastline) return 0;
	// 'lastline' should usually be h-1, but XnView apparently sets it to h.
	if(firstline>h-1 || lastline>h) return 0;
	if(w>DE_MAX_IMAGE_DIMENSION || h>DE_MAX_IMAGE_DIMENSION) return 0;
	if(w<1 || h<1) return 0;
	return 30;
}

void de_module_vivid(deark *c, struct deark_module_info *mi)
{
	mi->id = "vivid";
	mi->run_fn = de_run_vivid;
	mi->identify_fn = de_identify_vivid;
}

// **************************************************************************
// Apple volume label image
// Written by netpbm: ppmtoapplevol
// **************************************************************************

static de_byte applevol_get_gray_shade(de_byte clr)
{
	switch(clr) {
		// TODO: These gray shades may not be quite right. I can't find good
		// information about them.
	case 0x00: return 0xff;
	case 0xf6: return 0xee;
	case 0xf7: return 0xdd;
	case 0x2a: return 0xcc;
	case 0xf8: return 0xbb;
	case 0xf9: return 0xaa;
	case 0x55: return 0x99;
	case 0xfa: return 0x88;
	case 0xfb: return 0x77;
	case 0x80: return 0x66;
	case 0xfc: return 0x55;
	case 0xfd: return 0x44;
	case 0xab: return 0x33;
	case 0xfe: return 0x22;
	case 0xff: return 0x11;
	case 0xd6: return 0x00;
	}
	return 0xff;
}

static void de_run_applevol(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 w, h;
	de_int64 i, j;
	de_int64 p;
	de_byte palent;

	de_dbg(c, "In applevol module\n");
	w = de_getui16be(1);
	h = de_getui16be(3);
	if(!de_good_image_dimensions(c, w, h)) goto done;
	img = de_bitmap_create(c, w, h, 1);

	p = 5;
	for(j=0; j<h; j++) {
		for(i=0; i<w; i++) {
			palent = de_getbyte(p+w*j+i);
			de_bitmap_setpixel_gray(img, i, j, applevol_get_gray_shade(palent));
		}
	}

	de_bitmap_write_to_file(img, NULL);

done:
	de_bitmap_destroy(img);
}

static int de_identify_applevol(deark *c)
{
	de_byte buf[5];

	de_read(buf, 0, sizeof(buf));

	if(buf[0]==0x01 && buf[3]==0x00 && buf[4]==0x0c)
		return 20;
	return 0;
}

void de_module_applevol(deark *c, struct deark_module_info *mi)
{
	mi->id = "applevol";
	mi->run_fn = de_run_applevol;
	mi->identify_fn = de_identify_applevol;
}

// **************************************************************************
// TRS-80 "HR" ("High Resolution") image
// **************************************************************************

static void de_run_hr(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 width, height;
	de_int64 src_rowspan;
	de_int64 j;

	de_dbg(c, "In hr module\n");

	width = 640;
	height = 240;

	img = de_bitmap_create(c, width, height, 1);
	src_rowspan = (width+7)/8;

	for(j=0; j<height; j++) {
		de_convert_row_bilevel(c->infile, j*src_rowspan, img, j, 0);
	}

	de_bitmap_write_to_file(img, NULL);
	de_bitmap_destroy(img);
}

static int de_identify_hr(deark *c)
{
	if(de_input_file_has_ext(c, "hr")) {
		if(c->infile->len==19200) return 70;
		if(c->infile->len>19200 && c->infile->len<=19456) return 30;
	}
	return 0;
}

void de_module_hr(deark *c, struct deark_module_info *mi)
{
	mi->id = "hr";
	mi->run_fn = de_run_hr;
	mi->identify_fn = de_identify_hr;
}

// **************************************************************************
// RIPterm icon (.ICN)
// **************************************************************************

static void de_run_ripicon(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 width, height;
	de_int64 chunk_span;
	de_int64 src_rowspan;
	de_int64 i, j, k;
	de_byte x;
	de_uint32 palent;

	de_dbg(c, "In ripicon module\n");

	width = 1 + de_getui16le(0);
	height = 1 + de_getui16le(2);
	de_dbg(c, "dimensions: %dx%d\n", (int)width, (int)height);
	if(!de_good_image_dimensions(c, width, height)) goto done;

	img = de_bitmap_create(c, width, height, 3);
	chunk_span = (width+7)/8;
	src_rowspan = 4*chunk_span;

	for(j=0; j<height; j++) {
		for(i=0; i<width; i++) {
			palent = 0;
			for(k=0; k<4; k++) {
				x = de_get_bits_symbol(c->infile, 1, 4 + j*src_rowspan + k*chunk_span, i);
				palent = (palent<<1)|x;
			}
			de_bitmap_setpixel_rgb(img, i, j, de_palette_pc16(palent));
		}
	}

	de_bitmap_write_to_file(img, NULL);
done:
	de_bitmap_destroy(img);
}

static int de_identify_ripicon(deark *c)
{
	return 0;
}

void de_module_ripicon(deark *c, struct deark_module_info *mi)
{
	mi->id = "ripicon";
	mi->run_fn = de_run_ripicon;
	mi->identify_fn = de_identify_ripicon;
}
