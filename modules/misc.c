// This file is part of Deark, by Jason Summers.
// This software is in the public domain. See the file COPYING for details.

// This file is for miscellaneous formats that are easy to support.
// Combining them in one file speeds up compilation and development time.

#include <deark-config.h>
#include <deark-modules.h>
#include "fmtutil.h"

// **************************************************************************
// "copy" module
//
// This is a trivial module that makes a copy of the input file.
// **************************************************************************

static int de_identify_copy(deark *c)
{
	return 0;
}

static void de_run_copy(deark *c, const char *params)
{
	de_dbg(c, "In copy module\n");

	dbuf_create_file_from_slice(c->infile, 0, c->infile->len, "bin", NULL);
}

void de_module_copy(deark *c, struct deark_module_info *mi)
{
	mi->id = "copy";
	mi->run_fn = de_run_copy;
	mi->identify_fn = de_identify_copy;
}

// **************************************************************************
// zlib module
//
// This module is for decompressing zlib-compressed files.
// It uses the deark-miniz.c utilities, which in turn use miniz.c.
// **************************************************************************

static void de_run_zlib(deark *c, const char *params)
{
	dbuf *f = NULL;

	de_dbg(c, "In zlib module\n");

	f = dbuf_create_output_file(c, "unc", NULL);
	de_uncompress_zlib(c->infile, 0, c->infile->len, f);
	dbuf_close(f);
}

static int de_identify_zlib(deark *c)
{
	de_byte b[2];
	de_read(b, 0, 2);

	if((b[0]&0x0f) != 8)
		return 0;

	if(b[0]<0x08 || b[0]>0x78)
		return 0;

	if(((((unsigned int)b[0])<<8)|b[1])%31 != 0)
		return 0;

	return 50;
}

void de_module_zlib(deark *c, struct deark_module_info *mi)
{
	mi->id = "zlib";
	mi->run_fn = de_run_zlib;
	mi->identify_fn = de_identify_zlib;
}

// **************************************************************************
// HP 100LX / HP 200LX .ICN icon format
// **************************************************************************

static void de_run_hpicn(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 width, height;
	de_int64 src_rowspan;
	de_int64 j;

	de_dbg(c, "In hpicn module\n");

	width = de_getui16le(4);
	height = de_getui16le(6);

	img = de_bitmap_create(c, width, height, 1);
	src_rowspan = (width+7)/8;

	for(j=0; j<height; j++) {
		de_convert_row_bilevel(c->infile, 8+j*src_rowspan, img, j, DE_CVTR_WHITEISZERO);
	}

	de_bitmap_write_to_file(img, NULL);
	de_bitmap_destroy(img);
}

static int de_identify_hpicn(deark *c)
{
	de_byte b[8];
	de_read(b, 0, 8);
	if(!de_memcmp(b, "\x01\x00\x01\x00\x2c\x00\x20\x00", 8))
		return 100;
	if(!de_memcmp(b, "\x01\x00\x01\x00", 4))
		return 60;
	return 0;
}

void de_module_hpicn(deark *c, struct deark_module_info *mi)
{
	mi->id = "hpicn";
	mi->run_fn = de_run_hpicn;
	mi->identify_fn = de_identify_hpicn;
}


// **************************************************************************
// X11 "puzzle" format
// ftp://ftp.x.org/pub/unsupported/programs/puzzle/
// This is the format generated by Netpbm's ppmtopuzz utility.
// **************************************************************************

struct xpuzzctx {
	de_int64 w, h;
	de_int64 palentries;
};

static int xpuzz_read_header(deark *c, struct xpuzzctx *d)
{
	d->w = de_getui32be(0);
	d->h = de_getui32be(4);
	d->palentries = (de_int64)de_getbyte(8);
	if(d->w<1 || d->w>DE_MAX_IMAGE_DIMENSION) return 0;
	if(d->h<1 || d->h>DE_MAX_IMAGE_DIMENSION) return 0;
	if(d->palentries==0) d->palentries = 256;
	return 1;
}

static void de_run_xpuzzle(deark *c, const char *params)
{
	struct xpuzzctx *d = NULL;
	struct deark_bitmap *img = NULL;
	de_int64 i, j;
	de_uint32 pal[256];
	de_int64 p;

	de_dbg(c, "In xpuzzle module\n");

	d = de_malloc(c, sizeof(struct xpuzzctx));
	if(!xpuzz_read_header(c, d)) goto done;

	img = de_bitmap_create(c, d->w, d->h, 3);

	// Read the palette
	de_memset(pal, 0, sizeof(pal));
	p = 9;
	for(i=0; i<d->palentries; i++) {
		pal[i] = DE_MAKE_RGB(de_getbyte(p), de_getbyte(p+1), de_getbyte(p+2));
		p+=3;
	}

	// Read the bitmap
	for(j=0; j<d->h; j++) {
		for(i=0; i<d->w; i++) {
			de_bitmap_setpixel_rgb(img, i, j, pal[de_getbyte(p+d->w*j+i)]);
		}
	}

	de_bitmap_write_to_file(img, NULL);

done:
	de_bitmap_destroy(img);
	de_free(c, d);
}

static int de_identify_xpuzzle(deark *c)
{
	struct xpuzzctx *d = NULL;
	int retval = 0;

	d = de_malloc(c, sizeof(struct xpuzzctx));

	if(!xpuzz_read_header(c, d)) goto done;

	if(d->w * d->h + 3*d->palentries + 9 == c->infile->len) {
		retval = 20;
	}

done:
	de_free(c, d);
	return retval;
}

void de_module_xpuzzle(deark *c, struct deark_module_info *mi)
{
	mi->id = "xpuzzle";
	mi->run_fn = de_run_xpuzzle;
	mi->identify_fn = de_identify_xpuzzle;
}

// **************************************************************************
// Winzle! puzzle image
// **************************************************************************

static void de_run_winzle(deark *c, const char *params)
{
	de_byte buf[256];
	de_int64 xorsize;
	de_int64 i;
	dbuf *f = NULL;

	xorsize = c->infile->len >= 256 ? 256 : c->infile->len;
	de_read(buf, 0, xorsize);
	for(i=0; i<xorsize; i++) {
		buf[i] ^= 0x0d;
	}

	f = dbuf_create_output_file(c, "bmp", NULL);
	dbuf_write(f, buf, xorsize);
	if(c->infile->len > 256) {
		dbuf_copy(c->infile, 256, c->infile->len - 256, f);
	}
	dbuf_close(f);
}

static int de_identify_winzle(deark *c)
{
	de_byte b[18];
	de_read(b, 0, sizeof(b));

	if(b[0]==0x4f && b[1]==0x40) {
		if(b[14]==0x25 && b[15]==0x0d && b[16]==0x0d && b[17]==0x0d) {
			return 95;
		}
		return 40;
	}
	return 0;
}

void de_module_winzle(deark *c, struct deark_module_info *mi)
{
	mi->id = "winzle";
	mi->run_fn = de_run_winzle;
	mi->identify_fn = de_identify_winzle;
}

// **************************************************************************
// DCX
// **************************************************************************

static void de_run_dcx(deark *c, const char *params)
{
	de_uint32 *page_offset;
	de_int64 num_pages;
	de_int64 page;
	de_int64 page_size;

	de_dbg(c, "In dcx module\n");

	page_offset = de_malloc(c, 1023 * sizeof(de_uint32));
	num_pages = 0;
	while(num_pages < 1023) {
		page_offset[num_pages] = (de_uint32)de_getui32le(4 + 4*num_pages);
		if(page_offset[num_pages]==0)
			break;
		num_pages++;
	}

	de_dbg(c, "number of pages: %d\n", (int)num_pages);

	for(page=0; page<num_pages; page++) {
		if(page == num_pages-1) {
			// Last page. Asssume it goes to the end of file.
			page_size = c->infile->len - page_offset[page];
		}
		else {
			page_size = page_offset[page+1] - page_offset[page];
		}
		if(page_size<0) page_size=0;
		de_dbg(c, "page %d at %d, size=%d\n", (int)page, (int)page_offset[page],
			(int)page_size);

		dbuf_create_file_from_slice(c->infile, page_offset[page], page_size, "pcx", NULL);
	}
}

static int de_identify_dcx(deark *c)
{
	de_byte b[4];
	de_read(b, 0, 4);
	if(!de_memcmp(b, "\xb1\x68\xde\x3a", 4))
		return 100;
	return 0;
}

void de_module_dcx(deark *c, struct deark_module_info *mi)
{
	mi->id = "dcx";
	mi->run_fn = de_run_dcx;
	mi->identify_fn = de_identify_dcx;
}

// **************************************************************************
// Minolta RAW (MRW)
// **************************************************************************

static void do_mrw_seg_list(deark *c, de_int64 pos1, de_int64 len)
{
	de_int64 pos;
	de_byte seg_id[4];
	de_int64 data_len;

	pos = pos1;
	while(pos < pos1+len) {
		de_read(seg_id, pos, 4);
		data_len = de_getui32be(pos+4);
		pos+=8;
		if(pos+data_len > pos1+len) break;
		if(!de_memcmp(seg_id, "\0TTW", 4)) { // Exif
			de_fmtutil_handle_exif(c, pos, data_len);
		}
		pos+=data_len;
	}
}

static void de_run_mrw(deark *c, const char *params)
{
	de_int64 mrw_seg_size;

	mrw_seg_size = de_getui32be(4);
	do_mrw_seg_list(c, 8, mrw_seg_size);
}

static int de_identify_mrw(deark *c)
{
	de_byte b[4];
	de_read(b, 0, 4);
	if(!de_memcmp(b, "\x00\x4d\x52\x4d", 4))
		return 100;
	return 0;
}

void de_module_mrw(deark *c, struct deark_module_info *mi)
{
	mi->id = "mrw";
	mi->run_fn = de_run_mrw;
	mi->identify_fn = de_identify_mrw;
}

// **************************************************************************
// "Bob" bitmap image
// Used by the Bob ray tracer.
// **************************************************************************

static void de_run_bob(deark *c, const char *params)
{
	struct deark_bitmap *img = NULL;
	de_int64 w, h;
	de_int64 i, j;
	de_uint32 pal[256];
	de_int64 p;

	de_dbg(c, "In bob module\n");

	w = de_getui16le(0);
	h = de_getui16le(2);
	img = de_bitmap_create(c, w, h, 3);

	// Read the palette
	de_memset(pal, 0, sizeof(pal));
	p = 4;
	for(i=0; i<256; i++) {
		pal[i] = DE_MAKE_RGB(de_getbyte(p), de_getbyte(p+1), de_getbyte(p+2));
		p+=3;
	}

	// Read the bitmap
	for(j=0; j<h; j++) {
		for(i=0; i<w; i++) {
			de_bitmap_setpixel_rgb(img, i, j, pal[de_getbyte(p+w*j+i)]);
		}
	}

	de_bitmap_write_to_file(img, NULL);

	de_bitmap_destroy(img);
}

static int de_identify_bob(deark *c)
{
	de_int64 w, h;

	if(!de_input_file_has_ext(c, "bob")) return 0;

	w = de_getui16le(0);
	h = de_getui16le(2);
	if(c->infile->len == 4 + 768 + w*h) {
		return 100;
	}
	return 0;
}

void de_module_bob(deark *c, struct deark_module_info *mi)
{
	mi->id = "bob";
	mi->run_fn = de_run_bob;
	mi->identify_fn = de_identify_bob;
}
